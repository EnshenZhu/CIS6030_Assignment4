---
title: "R Notebook"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```
```{r}
# install.packages("R6")
# install.packages("ClusterR")
# install.packages("cluster")
# install.packages("DescTools")
# install.packages("igraph")
# install.packages("dbscan")
# install.packages("r2r")

# Loading package
library(ClusterR)
library(cluster)
library(DescTools)
library(igraph)
library(R6)
library(r2r)
```
```{r}
# import the iris data from the docker
result <- system("docker exec namenode hdfs dfs -cat ./input/iris.csv", intern = TRUE)
writeLines(result, "./hdbscan_manual/temp_iris.csv")
iris_data <- read.csv("./hdbscan_manual/temp_iris.csv",
                      header = FALSE,
                      colClasses = c(NA, NA, NA, NA, NA),
                      col.names = c("sepal_length", "sepal_width", "petal_length", "petal_width", "species"))
```
```{r}
# subtract the iris_params, which only contain the sepal and petal numberical values
iris_params <- iris_data[, -5]
# iris_params
```
## Part 1 - Work out the core distance, mutual reachability distance and mutual reachability distance graph
```{r}
# create distance matrix for each data point pairs
L2_dist_matrix = as.matrix(dist(iris_params, method = "euclidean"))
L2_dist_matrix
```
```{r}
# caluclate the core ditance for each data point base on parameter k
k_param <- 3 # the core distance of a point is the distance from the point to the k-th nearest neighbour.
core_dist <- apply(L2_dist_matrix, 1, FUN = function(x) Small(x, k = k_param + 1, unique = FALSE, na.last = NA)[k_param])

core_dist[1]
```
```{r}

# build the mutal distance matrix
dp_num = dim(iris_params)[1]
mutal_dist_matrix <- matrix(, nrow = dp_num, ncol = dp_num)

for (row_idx in 1:dp_num) {
  for (col_idx in 1:dp_num) {
    if (row_idx != col_idx) {
      #mutal distance is the max of (L2_dist(x,y), core_dist(x),core_dist(y))
      mutal_dist_matrix[row_idx, col_idx] <- max(L2_dist_matrix[row_idx, col_idx], core_dist[row_idx], core_dist[col_idx])
    }
    else {
      mutal_dist_matrix[row_idx, col_idx] = 0
    }
  }
}

# mutal_dist_matrix
```
## Part II Build the minimum spanning tree
```{r}
temp_graph = mutal_dist_matrix
# Step 1: Convert the matrix into the upper triangle matrix firstly
temp_graph[upper.tri(temp_graph)] <- 0

temp_graph_undirected <- as.undirected(graph.adjacency(temp_graph, weighted = TRUE))
graph_MST <- mst(temp_graph_undirected)
# graph_MST
```
```{r}
# Step 2: Turn back to the triangle matrix
temp_adjacent_matrix <- as_adjacency_matrix(graph_MST, type = "lower", attr = "weight")
MinimumSpanning_matrix <- matrix(temp_adjacent_matrix, nrow = dim(temp_adjacent_matrix)[1])
MinimumSpanning_matrix[upper.tri(MinimumSpanning_matrix)] <- 0
MinimumSpanning_matrix # Here is teh minimum spanning tree in the matrix format
```
## Part III
### Step0: Preset the class of the hieratical tree
```{r}
HieraticalTree <- R6Class("HieraticalTree",
                          public = list(MutualDistanceNode_ls = NA,
                                        DataPointsNode_ls = NA)
)

# MutualDistanceNode will be the internal nodes
TreeNodes <- R6Class("TreeNodes",
                     public = list(distance_val = NA,
                                   left = NULL,
                                   right = NULL,
                                   parentNode = NULL,

                                   initialize = function(distance_val = NA, left = NULL, right = NULL) {
                                     # stopifnot(is.double(distance_val))
                                     # stopifnot(is.numeric(left))
                                     # stopifnot(is.numeric(right))
                                     # Do I need to initialize the parentNode?
                                     self$distance_val = distance_val
                                     self$left = left
                                     self$right = right
                                   }
                     ))

# DataPointsNode will be leaf nodes
# DataPointsNode <- R6Class("DataPointsNode",
#                           public = list(x_coor = NA,
#                                         y_coor = NA,
#                                         parentNode = NA,
#
#                                         initialize = function(x_coor, y_coor = NA) {
#                                           self$x_coor = x_coor
#                                           self$y_coor = y_coor
#                                         }
#                           ))
```
### Step1: Get all edges, their corresponded element pairs, and sort them
```{r}
#fix the MST matrix
# arg_MST_matrix = dist(MinimumSpanning_matrix)
# arg_MST_matrix
```
```{r}
#RECALL dp_num should be the dimension size -> 150

the_HieraticalTree <- HieraticalTree$new()

# Create a distance dataFrame to store the (distance,x_coor,y_coor) info
N <- dp_num # pre-allocate the dp_num of rows <this might be overestimate> SHOULD BE 150 Lines
dist_DF <- data.frame(core_dist = rep(NA, N), point1_idx = rep(NA, N), point2_idx = rep(NA, N), # we need three columns
                      stringsAsFactors = FALSE) # you don't know levels yet

i <- 1
for (row_idx in 1:dp_num) {
  for (col_idx in 1:dp_num) {
    if (MinimumSpanning_matrix[row_idx, col_idx] != 0) {
      # add the (distance,x_coor,y_coor) to the dataFrame
      row_idx <- as.integer(row_idx)
      col_idx <- as.integer(col_idx)
      dist_DF[i,] <- list(MinimumSpanning_matrix[row_idx, col_idx], row_idx, col_idx)
      i <- i + 1
    }
  }
}

dist_DF <- dist_DF[order(dist_DF$core_dist),]
dist_DF

```
MST <- (10, 1, 3), (15, 2, 3)
POINTS: 1, 2, 3
EDGES 10, 15

step -1: sort all the mst edges
step 0: Node$new(1), Node$new(2), Node$new(3) # create all  leaf nodes -> hashmap [idx]/list Num = N
step 1: for n-1 eges: Node$new(10, find(1), find(3)), union(1,3)
Node$new(15, find(2), find(3)), union(2,3) # create all internal nodes -> hashmap [-i]; exp, key = -1, min edge, key -3, 3rd smallest edge

              For example: find(1) -> hashmap[1] -> leafnode(1); find(3) -> hahsmap[3] -> leafnode(3)
                           newInternalNode(-1)
                           union(1, 3) -> 1 partent -> 3 parent -> -1 (root)

                           find(2) -> hashamp[2] -> leafnode(2);
                           find(3) -> hashmap[-1] -> internalNode(-1)
                           antoher new InternalNode(-2)[15, hashmap[2], hashmap[-1]] # memory-costly
                           [15, 2, -1] # memory-firendly -> 2n-1 node -> hashmap
                           TreeNode (val, left, rigth)
                           TreeNoder.get(left) -> left (TreeNODE)/ -> hashmap[left] / key

                           union(2, 3) -> find(2) -> lfn(2), find(3) -> internal(-1) -> lfn(2) parent -> internal(-1) -> parent -> internalnode(-2)


               Take away: 1) UF union(nu1, nu2) -> nu_root; find(nu1) -> nu_root
                          2) hahstable (size(2n-1)), value -> empty Node()
                          for i in -n-1:n:
                                hashtable[i] <- EmptyNode()

                           1~n, set idx 1~n, // or do nothing
                          -1~-n-1, loop via *sorted* edge: union-find -> set left, right, value = edge
                          ================
                          You already got the tree here at hashamp[n-1]

                        1: 1, 3, 15
                        2: 2, -1, 10
                        ...
                        -internal_num: leaf_num, leafnum/interl_num, edge

## Step2 Generate a hashmap to store all nodes (including leaf nodes and internal nodes
```{r}
allNode_Map <- hashmap()

for (idx in (-dp_num + 1):dp_num) {
  idx = as.character(idx)
  insert(allNode_Map, idx, TreeNodes$new(0, NULL, NULL))
}

query(allNode_Map, "22")
```
```{r}
hc <- hclust(dist(MinimumSpanning_matrix), method = "complete", members = NULL)
hc
plot(hc, hang = -1)
```
